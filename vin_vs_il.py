# -*- coding: utf-8 -*-
"""Vin vs IL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iawKYrRMhMvocprDYD93cNJuW1VLBTsc
"""

import seaborn as sns
import pandas as pd

# Create a dataframe with the data
data = {'Vin': [63, 60, 57, 54, 51], 
        'IL_Z1': [3.023, 3.021, 3.014, 2.987, 2.937], 
        'IL_Z2': [3.084, 3.083, 3.074, 3.046, 2.993]}
df = pd.DataFrame(data)

# Combine the data for Z1 and Z2
df_combined = pd.concat([df['Vin'], df['IL_Z1'], df['IL_Z2']], axis=1)
df_combined = df_combined.melt(id_vars=['Vin'], var_name='Z', value_name='IL')

# Concatenate data
Vin = Vin1 + Vin2
IL = IL1 + IL2

# Plot the scatterplot with a regression line
sns.regplot(x='Vin', y='IL', data=df_combined)

# Show the slope value in the graph
import matplotlib.pyplot as plt
import numpy as np

# Print slope value
slope = reg[0]
print("Slope value: {:.3f}".format(slope))

# Plot data points and regression line
plt.scatter(Vin1, IL1, color='blue', label='Z1')
plt.scatter(Vin2, IL2, color='red', label='Z2')
plt.plot(poly_x, poly_y, color='black')




slope, intercept = np.polyfit(df_combined['Vin'], df_combined['IL'], 1)
plt.text(52, 2.8, f'Slope: {slope:.4f}')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Input voltage (Vin) and output current (IL) data
Vin = np.array([63, 60, 57, 54, 51])
IL = np.array([3.023, 3.021, 3.014, 2.987, 2.937])

# Perform polynomial regression
reg = np.polyfit(Vin, IL, 2)
poly_x = np.linspace(min(Vin), max(Vin))
poly_y = np.polyval(reg, poly_x)

# Plot data points and regression line
plt.scatter(Vin, IL)
plt.plot(poly_x, poly_y, color='red')

# Add axis labels and title
plt.xlabel('Input voltage (V)')
plt.ylabel('Output current (I)')

# Show plot
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score, mean_squared_error

# Data for Z1 inductive load
Vin1 = [63, 60, 57, 54, 51]
IL1 = [3.023, 3.021, 3.014, 2.987, 2.937]

# Data for Z2 inductive load
Vin2 = [63, 60, 57, 54, 51]
IL2 = [3.084, 3.083, 3.074, 3.046, 2.993]

# Concatenate data
Vin = Vin1 + Vin2
IL = IL1 + IL2

# Reshape data
Vin = np.array(Vin).reshape((-1, 1))
IL = np.array(IL)

# Polynomial regression
poly = np.polyfit(Vin.flatten(), IL, 2)
poly_pred = np.polyval(poly, Vin)

# R-squared value
poly_r_squared = r2_score(IL, poly_pred)

# Mean squared error
poly_mse = mean_squared_error(IL, poly_pred)

# Coefficients and intercept value
a = poly[0]
b = poly[1]
c = poly[2]

print(f"Coefficients: a = {a:.3f}, b = {b:.3f}")
print(f"Intercept: c = {c:.3f}")


# Plot results
plt.scatter(Vin1, IL1, color='r', marker='*', label='Z = 1.94Ω + j42mH')
plt.scatter(Vin2, IL2, color='b', marker='+', label='Z = 2.1Ω + j41mH')

plt.plot(Vin, poly_pred, color='g', label=f'(R-squared = {poly_r_squared:.3f}, MSE = {poly_mse:.3f})')
plt.xlabel('Input Voltage (V)')
plt.ylabel('Load Current (A)')

plt.legend()
plt.show()

import numpy as np
from scipy import signal
import matplotlib.pyplot as plt

# Define Transfer Function
num = [1, 0, 0]
den = [1, 22.2, 123.4]
system = signal.TransferFunction(num, den)

# Obtain Frequency Response and Bode Plot
w, mag, phase = signal.bode(system)
freq_response = signal.freqresp(system, w=np.logspace(-2, 2, 1000))

# Frequency Response Plot
plt.figure(figsize=(8, 6))
plt.plot(freq_response[0], abs(freq_response[1]))
plt.title('Frequency Response')
plt.xlabel('Frequency (rad/s)')
plt.ylabel('Magnitude')
plt.grid(True)
plt.show()

# Bode Plot
plt.figure(figsize=(8, 6))
plt.semilogx(w, mag)
plt.title('Bode Plot')
plt.xlabel('Frequency (rad/s)')
plt.ylabel('Magnitude (dB)')
plt.grid(True)
plt.show()

import numpy as np
from scipy import signal
import matplotlib.pyplot as plt

# Define Transfer Function
num = [1, 0, 0]
den = [1, 22.2, 123.4]
system = signal.TransferFunction(num, den)

# Obtain Frequency Response and Bode Plot
w, mag, phase = signal.bode(system)
freq_response = signal.freqresp(system, w=np.logspace(-2, 2, 1000))

# Convert rad/s to Hz
freq_hz = freq_response[0] / (2 * np.pi)
w_hz = w / (2 * np.pi)

# Frequency Response Plot with Hz scale
plt.figure(figsize=(8, 6))
plt.plot(freq_hz, abs(freq_response[1]))
plt.title('Frequency Response')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Magnitude')
plt.grid(True)
plt.show()

# Bode Plot with Hz scale
plt.figure(figsize=(8, 6))
plt.semilogx(w_hz, mag)
plt.title('Bode Plot')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Magnitude (dB)')
plt.grid(True)
plt.show()

!pip install control

import matplotlib.pyplot as plt
import numpy as np
from control import tf, rlocus, margin, step_info

# Define the transfer function
num = [1, 22.2]
den = [1, 22.2, 123.4]
G = tf(num, den)

# Plot the root locus
rlocus(G)
plt.show()

# Compute the gain and phase margins
gm, pm, sm, wg, wp, ws = margin(G)
print('Gain margin:', gm)
print('Phase margin:', pm)

# Check if the system is stable using the RH criterion
if sm > 0:
    print('System is stable according to the RH criterion')
else:
    print('System is unstable according to the RH criterion')

# Compute the step response characteristics
info = step_info(G)
print('Settling time with maximum overshoot:', info['SettlingTime'])
print('Maximum overshoot (%):', info['Overshoot'])

# Plot the step response
t = np.linspace(0, 1, 1000)
u = np.ones_like(t)
t, y, _ = plt.step_response(G, t)
plt.plot(t, u, 'r--')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.show()

import numpy as np
from control import tf, bode_plot
import matplotlib.pyplot as plt

# Define the transfer function
num = [1, 22.2]
den = [1, 22.2, 123.4]
G = tf(num, den)

# Plot the bode plot
mag, phase, omega = bode_plot(G, dB=True, Hz=True, plot=True)

# Display the plot
plt.show()

"""## Asymptotically stable"""

import numpy as np
from control import tf, bode_plot, rlocus, nyquist_plot
import matplotlib.pyplot as plt

# Define the transfer function
num = [1, 22.2]
den = [1, 22.2, 123.4]
G = tf(num, den)

# Plot the root locus
rlocus(G)
plt.show()

# Plot the Nyquist plot
nyquist_plot(G)
plt.show()

# Plot the bode plot with frequency in rad/s
mag, phase, omega = bode_plot(G, dB=True, omega=np.logspace(-1, 3, 1000), plot=True)


# Display the plot
plt.show()

from control import margin

num = [1, 22.2]
den = [1, 22.2, 123.4]
G = tf(num, den)

gm, pm, wg, wp = margin(G)

print('Gain margin: {:.2f} dB'.format(gm))
print('Phase margin: {:.2f} degrees'.format(pm))

import numpy as np
import matplotlib.pyplot as plt

# Data for Z1 inductive load
Vin1 = [63, 60, 57, 54, 51]
IL1 = [3.023, 3.021, 3.014, 2.987, 2.937]

# Data for Z2 inductive load
Vin2 = [63, 60, 57, 54, 51]
IL2 = [3.084, 3.083, 3.074, 3.046, 2.993]

# Concatenate data
Vin = Vin1 + Vin2
IL = IL1 + IL2

# Reshape data
Vin = np.array(Vin).reshape ((-1,1))
IL = np.array(IL).reshape ((-1,1))

# Quadratic regression
poly = np.polyfit(Vin.flatten(), IL, 2)
poly_pred = np.polyval(poly, Vin)

# Residuals
resid = IL - poly_pred


# Residual plot
plt.scatter(Vin, resid, color='blue')
plt.axhline(y=0, color='red', linestyle='-')
plt.xlabel('Input Voltage (V)')
plt.ylabel('Residuals')
plt.title('Residual Plot for Quadratic Regression Model')
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# Data for Z1 inductive load
Vin1 = [63, 60, 57, 54, 51]
IL1 = [3.023, 3.021, 3.014, 2.987, 2.937]

# Data for Z2 inductive load
Vin2 = [63, 60, 57, 54, 51]
IL2 = [3.084, 3.083, 3.074, 3.046, 2.993]

# Fit linear regression model for Z1
reg1 = LinearRegression().fit(np.array(Vin1).reshape(-1, 1), IL1)
r2_1 = r2_score(IL1, reg1.predict(np.array(Vin1).reshape(-1, 1)))

# Fit linear regression model for Z2
reg2 = LinearRegression().fit(np.array(Vin2).reshape(-1, 1), IL2)
r2_2 = r2_score(IL2, reg2.predict(np.array(Vin2).reshape(-1, 1)))

# Plot the linear regression models for Z1 and Z2
fig, axs = plt.subplots(1, 2, figsize=(10, 5))

axs[0].scatter(Vin1, IL1)
axs[0].plot(Vin1, reg1.predict(np.array(Vin1).reshape(-1, 1)), color='red')
axs[0].set_xlabel('Vin1')
axs[0].set_ylabel('IL1')
axs[0].set_title(f"Z1: r-squared = {r2_1:.3f}")

axs[1].scatter(Vin2, IL2)
axs[1].plot(Vin2, reg2.predict(np.array(Vin2).reshape(-1, 1)), color='red')
axs[1].set_xlabel('Vin2')
axs[1].set_ylabel('IL2')
axs[1].set_title(f"Z2: r-squared = {r2_2:.3f}")

plt.show()

import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# Data for Z1 inductive load
Vin1 = [63, 60, 57, 54, 51]
IL1 = [3.023, 3.021, 3.014, 2.987, 2.937]

# Data for Z2 inductive load
Vin2 = [63, 60, 57, 54, 51]
IL2 = [3.084, 3.083, 3.074, 3.046, 2.993]

# Fit linear regression model for Z1
reg1 = LinearRegression().fit(np.array(Vin1).reshape(-1, 1), IL1)
r2_1 = r2_score(IL1, reg1.predict(np.array(Vin1).reshape(-1, 1)))

# Fit linear regression model for Z2
reg2 = LinearRegression().fit(np.array(Vin2).reshape(-1, 1), IL2)
r2_2 = r2_score(IL2, reg2.predict(np.array(Vin2).reshape(-1, 1)))

# Combine the plots for Z1 and Z2
fig, ax = plt.subplots(figsize=(8, 6))

ax.scatter(Vin1, IL1, label='Z1')
ax.plot(Vin1, reg1.predict(np.array(Vin1).reshape(-1, 1)), color='red')

ax.scatter(Vin2, IL2, label='Z2')
ax.plot(Vin2, reg2.predict(np.array(Vin2).reshape(-1, 1)), color='green')

ax.set_xlabel('Vin')
ax.set_ylabel('IL')
ax.set_title("Linear Regression Models for Z1 and Z2")

# Add a legend and show the plot
ax.legend()
plt.show()

# Calculate r-squared values
r2_combined = r2_score(IL1 + IL2, reg1.predict(np.array(Vin1).reshape(-1, 1)).tolist() + reg2.predict(np.array(Vin2).reshape(-1, 1)).tolist())
print(f"Combined r-squared value: {r2_combined:.3f}")

import numpy as np
import matplotlib.pyplot as plt

# Data for Z1 inductive load
Vin1 = [63, 60, 57, 54, 51]
IL1 = [3.023, 3.021, 3.014, 2.987, 2.937]

# Data for Z2 inductive load
Vin2 = [63, 60, 57, 54, 51]
IL2 = [3.084, 3.083, 3.074, 3.046, 2.993]

# Linear regression for Z1
m1, b1 = np.polyfit(Vin1, IL1, 1)
IL1_linear = m1*np.array(Vin1) + b1
r2_1 = np.corrcoef(Vin1, IL1)[0, 1]**2

# Polynomial regression for Z1
p1 = np.polyfit(Vin1, IL1, 2)
IL1_poly = np.polyval(p1, Vin1)
r2_2 = np.corrcoef(Vin1, IL1_poly)[0, 1]**2

# Linear regression for Z2
m2, b2 = np.polyfit(Vin2, IL2, 1)
IL2_linear = m2*np.array(Vin2) + b2
r2_3 = np.corrcoef(Vin2, IL2)[0, 1]**2

# Polynomial regression for Z2
p2 = np.polyfit(Vin2, IL2, 2)
IL2_poly = np.polyval(p2, Vin2)
r2_4 = np.corrcoef(Vin2, IL2_poly)[0, 1]**2

# Plot linear regression for Z1
plt.figure()
plt.scatter(Vin1, IL1)
plt.plot(Vin1, IL1_linear, 'r')
plt.xlabel('Input voltage (V)')
plt.ylabel('Inductor current (A)')
plt.title('Linear regression for Z1 (R-squared = {:.4f})'.format(r2_1))
plt.show()

# Plot polynomial regression for Z1
plt.figure()
plt.scatter(Vin1, IL1)
plt.plot(Vin1, IL1_poly, 'r')
plt.xlabel('Input voltage (V)')
plt.ylabel('Inductor current (A)')
plt.title('Polynomial regression for Z1 (R-squared = {:.4f})'.format(r2_2))
plt.show()

# Plot linear regression for Z2
plt.figure()
plt.scatter(Vin2, IL2)
plt.plot(Vin2, IL2_linear, 'r')
plt.xlabel('Input voltage (V)')
plt.ylabel('Inductor current (A)')
plt.title('Linear regression for Z2 (R-squared = {:.4f})'.format(r2_3))
plt.show()

# Plot polynomial regression for Z2
plt.figure()
plt.scatter(Vin2, IL2)
plt.plot(Vin2, IL2_poly, 'r')
plt.xlabel('Input voltage (V)')
plt.ylabel('Inductor current (A)')
plt.title('Polynomial regression for Z2 (R-squared = {:.4f})'.format(r2_4))
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
from sklearn.preprocessing import PolynomialFeatures

# Separate data
Vin1 = [63, 60, 57, 54, 51]
IL1 = [3.023, 3.021, 3.014, 2.987, 2.937]
Vin2 = [63, 60, 57, 54, 51]
IL2 = [3.084, 3.083, 3.074, 3.046, 2.993]

# Concatenate data
Vin = Vin1 + Vin2
IL = IL1 + IL2

# Linear regression
model_lin = LinearRegression().fit(np.array(Vin).reshape(-1, 1), IL)
r_sq_lin = r2_score(IL, model_lin.predict(np.array(Vin).reshape(-1, 1)))
plt.scatter(Vin, IL, color='blue')
plt.plot(Vin, model_lin.predict(np.array(Vin).reshape(-1, 1)), color='red')
plt.title('Linear Regression (r-squared = {:.3f})'.format(r_sq_lin))
plt.xlabel('Vin')
plt.ylabel('IL')
plt.show()

# Polynomial regression
degree = 2
poly = PolynomialFeatures(degree)
X_poly = poly.fit_transform(np.array(Vin).reshape(-1, 1))
model_poly = LinearRegression().fit(X_poly, IL)
r_sq_poly = r2_score(IL, model_poly.predict(X_poly))
plt.scatter(Vin, IL, color='blue')
plt.plot(Vin, model_poly.predict(poly.fit_transform(np.array(Vin).reshape(-1, 1))), color='red')
plt.title('Polynomial Regression (degree = {}, r-squared = {:.3f})'.format(degree, r_sq_poly))
plt.xlabel('Input voltage(V)')
plt.ylabel('Output current(I)')
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
from sklearn.preprocessing import PolynomialFeatures

# Data for Z1 inductive load
Vin1 = [63, 60, 57, 54, 51]
IL1 = [3.023, 3.021, 3.014, 2.987, 2.937]

# Data for Z2 inductive load
Vin2 = [63, 60, 57, 54, 51]
IL2 = [3.084, 3.083, 3.074, 3.046, 2.993]

# Concatenate data
Vin = Vin1 + Vin2
IL = IL1 + IL2

# Create arrays for Z1 and Z2 data
Z1_Vin = np.array(Vin1)
Z1_IL = np.array(IL1)
Z2_Vin = np.array(Vin2)
Z2_IL = np.array(IL2)

# Create linear regression model for all data
reg = LinearRegression().fit(np.array(Vin).reshape(-1, 1), np.array(IL).reshape(-1, 1))
r_squared_linear = r2_score(IL, reg.predict(np.array(Vin).reshape(-1, 1)))

# Create polynomial regression model for all data
poly = PolynomialFeatures(degree=2)
X_poly = poly.fit_transform(np.array(Vin).reshape(-1, 1))
poly_reg = LinearRegression().fit(X_poly, np.array(IL).reshape(-1, 1))
r_squared_poly = r2_score(IL, poly_reg.predict(X_poly))

# Plot linear regression model
plt.figure(figsize=(4,4))
plt.scatter(Z1_Vin, Z1_IL, color='red', label='Z1')
plt.scatter(Z2_Vin, Z2_IL, color='blue', label='Z2')
plt.plot(Vin, reg.predict(np.array(Vin).reshape(-1, 1)), color='green')
plt.xlabel('Input voltage (V)')
plt.ylabel('Output current (A)')

plt.legend()
plt.text(58, 2.98, f'R-squared = {r_squared_linear:.3f}')

# Plot polynomial regression model
plt.figure(figsize=(4,4))
plt.scatter(Z1_Vin, Z1_IL, color='red', label='Z1')
plt.scatter(Z2_Vin, Z2_IL, color='blue', label='Z2')
plt.plot(Vin, poly_reg.predict(poly.fit_transform(np.array(Vin).reshape(-1, 1))), color='green')
plt.xlabel('Input voltage (V)')
plt.ylabel('Output current (A)')

plt.legend()
plt.text(58, 2.98, f'R-squared = {r_squared_poly:.3f}')

plt.show()

pip install control

import numpy as np
import matplotlib.pyplot as plt

# Define the circuit parameters
V = 39.6  # voltage input (V)
R = 1.94  # resistance (ohm)
L = 42e-3  # inductance (H)

# Define the time range for the plot
t = np.linspace(0, 0.2, 1000)  # time range from 0 to 0.2 seconds

# Calculate the current response
i = (V/R) * (1 - np.exp(-R*t/L))  # current (A)

# Plot the current response
plt.plot(t, i)
plt.xlabel('Time (s)')
plt.ylabel('Current (A)')
plt.title('RL Circuit Current Response')
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Define the circuit parameters
V = 39.6  # voltage input (V)
R = 1.94  # resistance (ohm)
L = 42e-3  # inductance (H)
i0 = 3  # initial current (A)

# Define the time range for the plot
t = np.linspace(0, 0.2, 1000)  # time range from 0 to 0.2 seconds

# Calculate the current response
i = i0 * np.exp(-R*t/L) + (V/R) * (1 - np.exp(-R*t/L))  # current (A)

# Plot the current response
plt.plot(t, i)
plt.xlabel('Time (s)')
plt.ylabel('Current (A)')
plt.title('RL Circuit Current Response')
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Define the circuit parameters
R = 1.94
L = 42e-3

# Define the frequency range for the plot
f = np.logspace(0, 3, 1000)

# Calculate the magnitude and phase of the frequency response
w = 2*np.pi*f
H_mag = 1/np.sqrt(w**2*L**2 + R**2)
H_phase = -np.arctan(w*L/R)*180/np.pi

# Plot the magnitude and phase of the frequency response
fig, ax = plt.subplots(2, 1, figsize=(8, 6), sharex=True)

ax[0].semilogx(f, 20*np.log10(H_mag))
ax[0].set_ylabel('Magnitude (dB)')
ax[0].grid()

ax[1].semilogx(f, H_phase)
ax[1].set_xlabel('Frequency (Hz)')
ax[1].set_ylabel('Phase (deg)')
ax[1].grid()

plt.suptitle('Frequency Response of Inductive Load')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Define the circuit parameters
R = 1.94 # ohm
L = 42e-3 # H

# Define the frequency range to plot
f = np.logspace(0, 5, num=1000)

# Calculate the frequency response
w = 2*np.pi*f
H = R / np.sqrt(R**2 + (w*L)**2)

# Calculate the cutoff frequency
fc = 1 / (2*np.pi*R*L)

# Plot the frequency response
fig, ax = plt.subplots()
ax.semilogx(f, 20*np.log10(H))
ax.axvline(fc, color='r', linestyle='--')
ax.set_xlabel('Frequency (Hz)')
ax.set_ylabel('Magnitude (dB)')
ax.set_title('Frequency Response of Inductive Load')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Define the circuit parameters
R = 1.94   # Resistance (ohms)
L = 42e-3  # Inductance (H)

# Define the frequency range for the plot
f = np.logspace(0, 5, 500)

# Calculate the frequency response of the inductive load
w = 2 * np.pi * f
ZL = 1j * w * L  # Inductive impedance
Z = R + ZL      # Total impedance
I = 1 / Z       # Current through the inductor
V = I * ZL      # Voltage across the inductor
H = np.abs(V / 39.6)  # Magnitude response

# Plot the frequency response
fig, ax = plt.subplots()
ax.loglog(f, H)

# Add a vertical line to indicate the cutoff frequency
fc = 1 / (2 * np.pi * R * L)
ax.axvline(fc, color='red', linestyle='--')
ax.text(fc, 0.1, f'fc = {fc:.2f} Hz', color='red')

# Add axis labels and title
ax.set_xlabel('Frequency (Hz)')
ax.set_ylabel('Magnitude')
ax.set_title('Frequency Response of Inductive Load')

plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Define the circuit parameters
R = 1.94   # Resistance (ohms)
L = 42e-3  # Inductance (H)

# Define the frequency range for the plot
f = np.logspace(0, 5, 500)

# Calculate the frequency response of the inductive load
w = 2 * np.pi * f
ZL = 1j * w * L  # Inductive impedance
Z = R + ZL      # Total impedance
I = 1 / Z       # Current through the inductor
V = I * ZL      # Voltage across the inductor
H = np.abs(V / 39.6)  # Magnitude response

# Plot the frequency response
fig, ax = plt.subplots()
ax.loglog(f, H)

# Add a vertical line to indicate the cutoff frequency
fc = 1 / (2 * np.pi * R * L)
ax.axvline(fc, color='red', linestyle='--')
ax.text(fc, 0.1, f'fc = {fc:.2f} Hz', color='red')

# Add axis labels and title
ax.set_xlabel('Frequency (Hz)')
ax.set_ylabel('Magnitude')
ax.set_title('Frequency Response of Inductive Load')

plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Circuit parameters
Vin = 63  # Supply DC voltage
Iout = 3  # Load current
Vout = 39.6  # Load voltage
fsw = 10000  # Switching frequency
R = 1  # Capacitor ESR
L = 3.7e-3  # Inductance
C = 6.84e-6  # Capacitance
Zload = 13.33  # Load impedance
fload = 50  # Load frequency

# LC filter transfer function
def H(jw, R, L, C):
    w = 2 * np.pi * jw
    Q = R * np.sqrt(C/L)
    H = 1 / (1 + (w*R*C)**2 - 1j*w*R*C/Q)
    return H

# Frequency range
f = np.logspace(1, 5, num=1000)

# Magnitude and phase response of the LC filter
H_mag = 20*np.log10(np.abs(H(2*np.pi*f, R, L, C)))
H_phase = np.angle(H(2*np.pi*f, R, L, C))*180/np.pi

# Plot the frequency response
fig, ax1 = plt.subplots()

color = 'tab:red'
ax1.set_xlabel('Frequency (Hz)')
ax1.set_ylabel('Magnitude (dB)', color=color)
ax1.semilogx(f, H_mag, color=color)
ax1.tick_params(axis='y', labelcolor=color)

ax2 = ax1.twinx()

color = 'tab:blue'
ax2.set_ylabel('Phase (deg)', color=color)
ax2.semilogx(f, H_phase, color=color)
ax2.tick_params(axis='y', labelcolor=color)

fig.tight_layout()
plt.show()